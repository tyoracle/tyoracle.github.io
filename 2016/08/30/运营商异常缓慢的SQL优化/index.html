<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>运营商异常缓慢SQL优化 | IT 职业生涯规划</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="运营商异常缓慢SQL优化今天到一个运营商进行深度巡检时，发现一条SQL运行次数频繁，并且占用资源非常高，这条SQL是对两个千万级的大表进行关联，根据电话号码进行查询，原来的语句运行非常缓慢，常常半个小时都执行不完，真不知道业务是怎么忍受运行这么缓慢的SQL。
因为需要对客户信息进行保密，只能在自己电脑上模拟相应的数据与优化结果
先创建两个表，然后模拟表的数据，分别插入3千万与2千5百万">
<meta property="og:type" content="article">
<meta property="og:title" content="运营商异常缓慢SQL优化">
<meta property="og:url" content="http://tyoracle.com/2016/08/30/运营商异常缓慢的SQL优化/index.html">
<meta property="og:site_name" content="IT 职业生涯规划">
<meta property="og:description" content="运营商异常缓慢SQL优化今天到一个运营商进行深度巡检时，发现一条SQL运行次数频繁，并且占用资源非常高，这条SQL是对两个千万级的大表进行关联，根据电话号码进行查询，原来的语句运行非常缓慢，常常半个小时都执行不完，真不知道业务是怎么忍受运行这么缓慢的SQL。
因为需要对客户信息进行保密，只能在自己电脑上模拟相应的数据与优化结果
先创建两个表，然后模拟表的数据，分别插入3千万与2千5百万">
<meta property="og:updated_time" content="2017-02-03T09:15:46.155Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="运营商异常缓慢SQL优化">
<meta name="twitter:description" content="运营商异常缓慢SQL优化今天到一个运营商进行深度巡检时，发现一条SQL运行次数频繁，并且占用资源非常高，这条SQL是对两个千万级的大表进行关联，根据电话号码进行查询，原来的语句运行非常缓慢，常常半个小时都执行不完，真不知道业务是怎么忍受运行这么缓慢的SQL。
因为需要对客户信息进行保密，只能在自己电脑上模拟相应的数据与优化结果
先创建两个表，然后模拟表的数据，分别插入3千万与2千5百万">
  
    <link rel="alternate" href="/atom.xml" title="IT 职业生涯规划" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">IT 职业生涯规划</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">时间的朋友</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://tyoracle.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-运营商异常缓慢的SQL优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/30/运营商异常缓慢的SQL优化/" class="article-date">
  <time datetime="2016-08-29T16:00:00.000Z" itemprop="datePublished">2016-08-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/oracle/">oracle</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      运营商异常缓慢SQL优化
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="运营商异常缓慢SQL优化"><a href="#运营商异常缓慢SQL优化" class="headerlink" title="运营商异常缓慢SQL优化"></a>运营商异常缓慢SQL优化</h1><p>今天到一个运营商进行深度巡检时，发现一条SQL运行次数频繁，并且占用资源非常高，这条SQL是对两个千万级的大表进行关联，根据电话号码进行查询，原来的语句运行非常缓慢，常常半个小时都执行不完，真不知道业务是怎么忍受运行这么缓慢的SQL。</p>
<p>因为需要对客户信息进行保密，只能在自己电脑上模拟相应的数据与优化结果</p>
<p>先创建两个表，然后模拟表的数据，分别插入3千万与2千5百万<br><a id="more"></a></p>
<pre><code> 
DROP TABLE t1;
create table t1 as
select
to_char(trunc(dbms_random.value(10000000000, 20000000000 ))) phone_no,
trunc(dbms_random.value(0, 30 )) ext,
lpad(rownum,10) v1,
rpad('x',100) padding
from
all_objects
where rownum <= 30="" 30000000;="" drop="" table="" t2;="" create="" t2="" as="" select="" to_char(trunc(dbms_random.value(10000000,="" 20000000000="" )))="" phone_no,="" trunc(dbms_random.value(0,="" ))="" ext,="" lpad(rownum,10)="" v1,="" rpad('x',100)="" padding="" from="" all_objects="" where="" rownum="" <="25000000;" code=""></=></code></pre>

<p>其原来的运行的SQL类似如下，运行半小时都不会出来结果的</p>
<pre><code> 
SELECT phone_no,ext,v1,padding
FROM t1
WHERE SUBSTR(t1.phone_no,1,8) IN
(SELECT t2.phone_no FROM t2 WHERE LENGTH(t2.phone_no)=8)
OR 
SUBSTR(t1.phone_no,1,9) IN
(SELECT t2.phone_no FROM t2 WHERE LENGTH(t2.phone_no)=9)
OR
SUBSTR(t1.phone_no,1,10) IN
(SELECT t2.phone_no FROM t2 WHERE LENGTH(t2.phone_no)=10)
OR
SUBSTR(t1.phone_no,1,11) IN
(SELECT t2.phone_no FROM t2 WHERE LENGTH(t2.phone_no)=11);

执行计划如下：
Execution Plan
/----------------------------------------------------------
Plan hash value: 2055931425

/---------------------------------------------------------------------------
| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
/---------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |    32 |  3168 |   159K  (1)| 00:31:54 |
|*  1 |  FILTER            |      |       |       |            |          |
|   2 |   TABLE ACCESS FULL| T1   | 66720 |  6450K|   379   (1)| 00:00:05 |
|*  3 |   TABLE ACCESS FULL| T2   |     5 |   110 |    76   (0)| 00:00:01 |
|*  4 |   TABLE ACCESS FULL| T2   |    31 |   682 |    25   (0)| 00:00:01 |
|*  5 |   TABLE ACCESS FULL| T2   |   389 |  8558 |     4   (0)| 00:00:01 |
|*  6 |   TABLE ACCESS FULL| T2   |   422 |  9284 |     3   (0)| 00:00:01 |
/---------------------------------------------------------------------------

Predicate Information (identified by operation id):
/---------------------------------------------------

   1 - filter( EXISTS (SELECT 0 FROM "T2" "T2" WHERE
              LENGTH("T2"."PHONE_NO")=8 AND "T2"."PHONE_NO"=SUBSTR(:B1,1,8)) OR
              EXISTS (SELECT 0 FROM "T2" "T2" WHERE LENGTH("T2"."PHONE_NO")=9 AND
              "T2"."PHONE_NO"=SUBSTR(:B2,1,9)) OR  EXISTS (SELECT 0 FROM "T2" "T2"
              WHERE LENGTH("T2"."PHONE_NO")=10 AND "T2"."PHONE_NO"=SUBSTR(:B3,1,10))
              OR  EXISTS (SELECT 0 FROM "T2" "T2" WHERE LENGTH("T2"."PHONE_NO")=11
              AND "T2"."PHONE_NO"=SUBSTR(:B4,1,11)))
   3 - filter(LENGTH("T2"."PHONE_NO")=8 AND
              "T2"."PHONE_NO"=SUBSTR(:B1,1,8))
   4 - filter(LENGTH("T2"."PHONE_NO")=9 AND
              "T2"."PHONE_NO"=SUBSTR(:B1,1,9))
   5 - filter(LENGTH("T2"."PHONE_NO")=10 AND
              "T2"."PHONE_NO"=SUBSTR(:B1,1,10))
   6 - filter(LENGTH("T2"."PHONE_NO")=11 AND
              "T2"."PHONE_NO"=SUBSTR(:B1,1,11))

Note
/-----
  - dynamic sampling used for this statement (level=2)
</code></pre>


<p>从上面的执行计划里比较容易看到两个问题：<br>1、两个大表，全表扫描，特别是T2全表扫了4次，并且使用filter,这个filter可以看成是NL连接的变种，你想想，几千万的表，做NL的连接，还要做几次，想想不慢也难啊<br>2、当前的执行计划使用了level 2的dynamic sampling，即代表当前表上没有统计信息或统计信息过旧，但是这个不是这条SQL运行缓慢的关键，因为重新收集了统计信息后，执行计划一样，运行时间一样。最重要的还是执行计划不好导致的。</p>
<p>既然知道了执行计划有问题，那我们就想办法优化吧，最简单的就是给T2的phone_no加上索引，效果立马显现。</p>
<pre><code> 
17:48:32 SQL> create index idx_t2_phoneno on t2(phone_no) ;

Index created.

18:18:48 SQL> exec DBMS_STATS.GATHER_TABLE_STATS (ownname => 'SYS' , tabname => 'T1',cascade => true, estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,method_opt=>'for all indexed columns size 1', granularity => 'ALL', degree => 1);

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.79
18:20:50 SQL> exec DBMS_STATS.GATHER_TABLE_STATS (ownname => 'SYS' , tabname => 'T2',cascade => true, estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,method_opt=>'for all indexed columns size 1', granularity => 'ALL', degree => 1);

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.56
</code></pre>

<p>重新运行SQL，加了索引后只需要2S左右就可以出来了结果了</p>
<pre><code> 
**Elapsed: 00:00:02.08**

Execution Plan
/----------------------------------------------------------
Plan hash value: 1293345318

/-------------------------------------------------------------------------------------
| Id  | Operation          | Name           | Rows  | Bytes | Cost (%CPU)| Time     |
/-------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |                |    32 |  3168 |  2035   (1)| 00:00:25 |
|*  1 |  FILTER            |                |       |       |            |          |
|   2 |   TABLE ACCESS FULL| T1             | 55915 |  5405K|   286   (2)| 00:00:04 |
|*  3 |   INDEX RANGE SCAN | IDX_T2_PHONENO |     1 |    12 |     1   (0)| 00:00:01 |
|*  4 |   INDEX RANGE SCAN | IDX_T2_PHONENO |     1 |    12 |     1   (0)| 00:00:01 |
|*  5 |   INDEX RANGE SCAN | IDX_T2_PHONENO |     1 |    12 |     1   (0)| 00:00:01 |
|*  6 |   INDEX RANGE SCAN | IDX_T2_PHONENO |     1 |    12 |     1   (0)| 00:00:01 |
/-------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
/---------------------------------------------------

   1 - filter( EXISTS (SELECT 0 FROM "T2" "T2" WHERE
              "T2"."PHONE_NO"=SUBSTR(:B1,1,8) AND LENGTH("T2"."PHONE_NO")=8) OR  EXISTS
              (SELECT 0 FROM "T2" "T2" WHERE "T2"."PHONE_NO"=SUBSTR(:B2,1,9) AND
              LENGTH("T2"."PHONE_NO")=9) OR  EXISTS (SELECT 0 FROM "T2" "T2" WHERE
              "T2"."PHONE_NO"=SUBSTR(:B3,1,10) AND LENGTH("T2"."PHONE_NO")=10) OR  EXISTS
              (SELECT 0 FROM "T2" "T2" WHERE "T2"."PHONE_NO"=SUBSTR(:B4,1,11) AND
              LENGTH("T2"."PHONE_NO")=11))
   3 - access("T2"."PHONE_NO"=SUBSTR(:B1,1,8))
       filter(LENGTH("T2"."PHONE_NO")=8)
   4 - access("T2"."PHONE_NO"=SUBSTR(:B1,1,9))
       filter(LENGTH("T2"."PHONE_NO")=9)
   5 - access("T2"."PHONE_NO"=SUBSTR(:B1,1,10))
       filter(LENGTH("T2"."PHONE_NO")=10)
   6 - access("T2"."PHONE_NO"=SUBSTR(:B1,1,11))
       filter(LENGTH("T2"."PHONE_NO")=11)


Statistics
/----------------------------------------------------------
          0  recursive calls
          0  db block gets
     448827  consistent gets  <<---但是消耗的逻辑读还是非常大 0="" 1="" 508="" 534="" physical="" reads="" redo="" size="" bytes="" sent="" via="" sql*net="" to="" client="" received="" from="" roundtrips="" sorts="" (memory)="" (disk)="" rows="" processed="" <="" code=""></---但是消耗的逻辑读还是非常大></code></pre>

<p>优化到这里，是不是就可以实现优化的目标了呢？对于大部分人来说，从跑半小时都出不来结果，到现在2S左右就能出结果，这是一个非常大的优化，但是对于TY来说，这样的SQL还有优化的空间，因为消耗的逻辑读还是非常大。做事要不不做，要做就要做极致，这是我一直信奉的原则。既然这样，那我们继续看看还有没有优化的空间吧。</p>
<p>从上面看，虽然加了索引，但是filter这个条件还是在，我们要想办法将这个filter去掉才能实现最佳的优化效果。<br>1）通过分析，发现当前语句存在多个or，导致了无法走hash join只能走filter表连接方式的问题，复杂的or条件无法做or expansion.那我们试试人工将OR拆开，将语句改写如下：</p>
<pre><code> 
SELECT  phone_no,ext,v1,padding
FROM t1
WHERE SUBSTR(t1.phone_no,1,8) IN
(SELECT t2.phone_no FROM t2 WHERE LENGTH(t2.phone_no)=8)
union all 
SELECT  phone_no,ext,v1,padding
FROM t1 where
SUBSTR(t1.phone_no,1,9) IN 
(SELECT t2.phone_no FROM t2 WHERE LENGTH(t2.phone_no)=9)
union all 
SELECT  phone_no,ext,v1,padding
FROM t1 where
SUBSTR(t1.phone_no,1,10) IN
(SELECT t2.phone_no FROM t2 WHERE LENGTH(t2.phone_no)=10)
union all 
SELECT phone_no,ext,v1,padding
FROM t1 where
SUBSTR(t1.phone_no,1,11) IN
(SELECT t2.phone_no FROM t2 WHERE LENGTH(t2.phone_no)=11);


**Elapsed: 00:00:00.79**

Execution Plan
/----------------------------------------------------------
Plan hash value: 3844306404

/----------------------------------------------------------------------------------
| Id  | Operation             | Name     | Rows  | Bytes | Cost (%CPU)| Time     |
/----------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |          |     4 |   484 |  2267  (76)| 00:00:28 |
|   1 |  UNION-ALL            |          |       |       |            |          |
|*  2 |   HASH JOIN RIGHT SEMI|          |     1 |   121 |   567   (2)| 00:00:07 |
|   3 |    VIEW               | VW_NSO_1 |   559 | 12298 |   280   (2)| 00:00:04 |
|*  4 |     TABLE ACCESS FULL | T2       |   559 |  6708 |   280   (2)| 00:00:04 |
|   5 |    TABLE ACCESS FULL  | T1       | 55915 |  5405K|   285   (2)| 00:00:04 |
|*  6 |   HASH JOIN RIGHT SEMI|          |     1 |   121 |   567   (2)| 00:00:07 |
|   7 |    VIEW               | VW_NSO_2 |   559 | 12298 |   280   (2)| 00:00:04 |
|*  8 |     TABLE ACCESS FULL | T2       |   559 |  6708 |   280   (2)| 00:00:04 |
|   9 |    TABLE ACCESS FULL  | T1       | 55915 |  5405K|   285   (2)| 00:00:04 |
|* 10 |   HASH JOIN RIGHT SEMI|          |     1 |   121 |   567   (2)| 00:00:07 |
|  11 |    VIEW               | VW_NSO_3 |   559 | 12298 |   280   (2)| 00:00:04 |
|* 12 |     TABLE ACCESS FULL | T2       |   559 |  6708 |   280   (2)| 00:00:04 |
|  13 |    TABLE ACCESS FULL  | T1       | 55915 |  5405K|   285   (2)| 00:00:04 |
|* 14 |   HASH JOIN RIGHT SEMI|          |     1 |   121 |   567   (2)| 00:00:07 |
|  15 |    VIEW               | VW_NSO_4 |   559 | 12298 |   280   (2)| 00:00:04 |
|* 16 |     TABLE ACCESS FULL | T2       |   559 |  6708 |   280   (2)| 00:00:04 |
|  17 |    TABLE ACCESS FULL  | T1       | 55915 |  5405K|   285   (2)| 00:00:04 |
/----------------------------------------------------------------------------------

Predicate Information (identified by operation id):
/---------------------------------------------------

   2 - access("PHONE_NO"=SUBSTR("T1"."PHONE_NO",1,8))
   4 - filter(LENGTH("T2"."PHONE_NO")=8)
   6 - access("PHONE_NO"=SUBSTR("T1"."PHONE_NO",1,9))
   8 - filter(LENGTH("T2"."PHONE_NO")=9)
  10 - access("PHONE_NO"=SUBSTR("T1"."PHONE_NO",1,10))
  12 - filter(LENGTH("T2"."PHONE_NO")=10)
  14 - access("PHONE_NO"=SUBSTR("T1"."PHONE_NO",1,11))
  16 - filter(LENGTH("T2"."PHONE_NO")=11)


Statistics
/----------------------------------------------------------
          0  recursive calls
          0  db block gets
       8244  consistent gets       <<--逻辑读已经降到一万以下 0="" 1="" 508="" 534="" physical="" reads="" redo="" size="" bytes="" sent="" via="" sql*net="" to="" client="" received="" from="" roundtrips="" sorts="" (memory)="" (disk)="" rows="" processed="" <="" code=""></--逻辑读已经降到一万以下></code></pre>

<p>通过采用改写为union 的方式来解决即可。可以看到，当前执行计划已经变成hash join，不再存在filter连接了。但现在对于这条SQL来说，是不是最优的呢？我们继续考虑一下，创建函数索引，是不是能更优化？</p>
<pre><code> 
create index IDX_T1_PHONE_NO8 on t1(SUBSTR(phone_no,1,8));
create index IDX_T1_PHONE_NO9 on t1(SUBSTR(phone_no,1,9));

**Elapsed: 00:00:00.52**

Execution Plan
----------------------------------------------------------
Plan hash value: 2507792230

----------------------------------------------------------------------------------------------------
| Id  | Operation                       | Name             | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                |                  |  2236 |   216K|  1971  (68)| 00:00:24 |
|   1 |  UNION-ALL                      |                  |       |       |            |          |
|   2 |   VIEW                          | VM_NWVW_5        |   559 | 55341 |   647   (1)| 00:00:08 |
|   3 |    HASH UNIQUE                  |                  |   559 | 74347 |   647   (1)| 00:00:08 |
|   4 |     NESTED LOOPS                |                  |   565 | 75145 |   646   (1)| 00:00:08 |
|*  5 |      INDEX FAST FULL SCAN       | IDX_T2_PHONENO   |   559 |  6708 |    51   (4)| 00:00:01 |
|   6 |      TABLE ACCESS BY INDEX ROWID| T1               |     1 |   121 |     3   (0)| 00:00:01 |
|*  7 |       INDEX RANGE SCAN          | IDX_T1_PHONE_NO8 |     1 |       |     1   (0)| 00:00:01 |
|   8 |   VIEW                          | VM_NWVW_6        |   559 | 55341 |   647   (1)| 00:00:08 |
|   9 |    HASH UNIQUE                  |                  |   559 | 74906 |   647   (1)| 00:00:08 |
|  10 |     NESTED LOOPS                |                  |   565 | 75710 |   646   (1)| 00:00:08 |
|* 11 |      INDEX FAST FULL SCAN       | IDX_T2_PHONENO   |   559 |  6708 |    51   (4)| 00:00:01 |
|  12 |      TABLE ACCESS BY INDEX ROWID| T1               |     1 |   122 |     3   (0)| 00:00:01 |
|* 13 |       INDEX RANGE SCAN          | IDX_T1_PHONE_NO9 |     1 |       |     1   (0)| 00:00:01 |
|  14 |   VIEW                          | VM_NWVW_7        |   559 | 55341 |   339   (3)| 00:00:05 |
|  15 |    HASH UNIQUE                  |                  |   559 | 77701 |   339   (3)| 00:00:05 |
|* 16 |     HASH JOIN                   |                  |   565 | 78535 |   337   (2)| 00:00:05 |
|* 17 |      INDEX FAST FULL SCAN       | IDX_T2_PHONENO   |   559 |  6708 |    51   (4)| 00:00:01 |
|  18 |      TABLE ACCESS FULL          | T1               | 55915 |  6934K|   285   (2)| 00:00:04 |
|  19 |   VIEW                          | VM_NWVW_8        |   559 | 55341 |   339   (3)| 00:00:05 |
|  20 |    HASH UNIQUE                  |                  |   559 | 77701 |   339   (3)| 00:00:05 |
|* 21 |     HASH JOIN                   |                  |   565 | 78535 |   337   (2)| 00:00:05 |
|* 22 |      INDEX FAST FULL SCAN       | IDX_T2_PHONENO   |   559 |  6708 |    51   (4)| 00:00:01 |
|  23 |      TABLE ACCESS FULL          | T1               | 55915 |  6934K|   285   (2)| 00:00:04 |
----------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   5 - filter(LENGTH("T2"."PHONE_NO")=8)
   7 - access(SUBSTR("PHONE_NO",1,8)="T2"."PHONE_NO")
  11 - filter(LENGTH("T2"."PHONE_NO")=9)
  13 - access(SUBSTR("PHONE_NO",1,9)="T2"."PHONE_NO")
  16 - access(SUBSTR("PHONE_NO",1,9)=SUBSTR("T2"."PHONE_NO",1,9) AND
              "T2"."PHONE_NO"=SUBSTR("T1"."PHONE_NO",1,10) AND
              SUBSTR("PHONE_NO",1,8)=SUBSTR("T2"."PHONE_NO",1,8))
  17 - filter(LENGTH("T2"."PHONE_NO")=10)
  21 - access(SUBSTR("PHONE_NO",1,9)=SUBSTR("T2"."PHONE_NO",1,9) AND
              "T2"."PHONE_NO"=SUBSTR("T1"."PHONE_NO",1,11) AND
              SUBSTR("PHONE_NO",1,8)=SUBSTR("T2"."PHONE_NO",1,8))
  22 - filter(LENGTH("T2"."PHONE_NO")=11)


Statistics
----------------------------------------------------------
          0  recursive calls
          0  db block gets
       3138  consistent gets           <<--逻辑读降到最低了 0="" 1="" 508="" 534="" physical="" reads="" redo="" size="" bytes="" sent="" via="" sql*net="" to="" client="" received="" from="" roundtrips="" sorts="" (memory)="" (disk)="" rows="" processed="" <="" code=""></--逻辑读降到最低了></code></pre>
上述的优化，对于这条SQL，应该是最优了，消耗的逻辑读最少，执行时间也只需要52ms，但因为多了两个函数索引的维护开销，如果这两张表是频繁的更新插入的话，索引的维护会有一定的影响。那我们看看不建立索引，有没有一个平衡的优化方案？

2）    其实存在多种改写方法，这里给出另一种.t2只设置到phone_no和虚拟的length(phone_no)两个字段,即行长为14个字节，千万级的表的大小为14*10，000，000字节即只有100M左右，采用with as写法，避免去创建复合索引（phone_no，length(phone_no)）走index fast full scan来避免全表扫描，避免了索引维护成本。

<pre><code> 
with a as
 (select /*+MATERIALIZE*/
   length(phone_no) as len, phone_no
    from t2)
select /*+use_hash(a,t1) leading(a t1)*/
 t1.phone_no, t1.ext, t1.v1, t1.padding
  from t1, a
 where (a.len = 8 and a.phone_no = substr(t1.phone_no, 1, 8))
    or (a.len = 9 and a.phone_no = substr(t1.phone_no, 1, 9))
    or (a.len = 10 and a.phone_no = substr(t1.phone_no, 1, 10))
    or (a.len = 11 and a.phone_no = substr(t1.phone_no, 1, 11));
</code></pre>
改写后数据库CBO优化器会自动展开or（不需要改写为union了，当然改写也可以）,展开后的执行计划如下
<pre><code> 
**Elapsed: 00:00:00.95**

Execution Plan
/----------------------------------------------------------
Plan hash value: 3776602953

/----------------------------------------------------------------------------------------------------------------
| Id  | Operation                  | Name                      | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |
/----------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT           |                           |   225K|    26M|       |  3957   (2)| 00:00:48 |
|   1 |  TEMP TABLE TRANSFORMATION |                           |       |       |       |            |          |
|   2 |   LOAD AS SELECT           | SYS_TEMP_0FD9D6613_2E5CA5 |       |       |       |            |          |
|   3 |    TABLE ACCESS FULL       | T2                        | 55914 |   655K|       |   279   (1)| 00:00:04 |
|   4 |   CONCATENATION            |                           |       |       |       |            |          |
|*  5 |    HASH JOIN               |                           | 56458 |  6836K|  2024K|   710   (2)| 00:00:09 |
|*  6 |     VIEW                   |                           | 55914 |  1365K|       |    29   (7)| 00:00:01 |
|   7 |      TABLE ACCESS FULL     | SYS_TEMP_0FD9D6613_2E5CA5 | 55914 |   655K|       |    29   (7)| 00:00:01 |
|   8 |     TABLE ACCESS FULL      | T1                        | 55915 |  5405K|       |   285   (2)| 00:00:04 |
|*  9 |    HASH JOIN               |                           | 56458 |  6836K|  2024K|   710   (2)| 00:00:09 |
|* 10 |     VIEW                   |                           | 55914 |  1365K|       |    29   (7)| 00:00:01 |
|  11 |      TABLE ACCESS FULL     | SYS_TEMP_0FD9D6613_2E5CA5 | 55914 |   655K|       |    29   (7)| 00:00:01 |
|  12 |     TABLE ACCESS FULL      | T1                        | 55915 |  5405K|       |   285   (2)| 00:00:04 |
|* 13 |    HASH JOIN               |                           | 56458 |  6836K|  2024K|   710   (2)| 00:00:09 |
|* 14 |     VIEW                   |                           | 55914 |  1365K|       |    29   (7)| 00:00:01 |
|  15 |      TABLE ACCESS FULL     | SYS_TEMP_0FD9D6613_2E5CA5 | 55914 |   655K|       |    29   (7)| 00:00:01 |
|  16 |     TABLE ACCESS FULL      | T1                        | 55915 |  5405K|       |   285   (2)| 00:00:04 |
|* 17 |    HASH JOIN               |                           | 56458 |  6836K|  2024K|   710   (2)| 00:00:09 |
|* 18 |     VIEW                   |                           | 55914 |  1365K|       |    29   (7)| 00:00:01 |
|  19 |      TABLE ACCESS FULL     | SYS_TEMP_0FD9D6613_2E5CA5 | 55914 |   655K|       |    29   (7)| 00:00:01 |
|  20 |     TABLE ACCESS FULL      | T1                        | 55915 |  5405K|       |   285   (2)| 00:00:04 |
/----------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
/---------------------------------------------------

   5 - access("A"."PHONE_NO"=SUBSTR("T1"."PHONE_NO",1,11))
   6 - filter("A"."LEN"=11)
   9 - access("A"."PHONE_NO"=SUBSTR("T1"."PHONE_NO",1,10))
       filter(LNNVL("A"."LEN"=11) OR LNNVL("A"."PHONE_NO"=SUBSTR("T1"."PHONE_NO",1,11)))
  10 - filter("A"."LEN"=10)
  13 - access("A"."PHONE_NO"=SUBSTR("T1"."PHONE_NO",1,9))
       filter((LNNVL("A"."LEN"=10) OR LNNVL("A"."PHONE_NO"=SUBSTR("T1"."PHONE_NO",1,10))) AND
              (LNNVL("A"."LEN"=11) OR LNNVL("A"."PHONE_NO"=SUBSTR("T1"."PHONE_NO",1,11))))
  14 - filter("A"."LEN"=9)
  17 - access("A"."PHONE_NO"=SUBSTR("T1"."PHONE_NO",1,8))
       filter((LNNVL("A"."LEN"=9) OR LNNVL("A"."PHONE_NO"=SUBSTR("T1"."PHONE_NO",1,9))) AND
              (LNNVL("A"."LEN"=10) OR LNNVL("A"."PHONE_NO"=SUBSTR("T1"."PHONE_NO",1,10))) AND (LNNVL("A"."LEN"=11) OR
              LNNVL("A"."PHONE_NO"=SUBSTR("T1"."PHONE_NO",1,11))))
  18 - filter("A"."LEN"=8)


Statistics
/----------------------------------------------------------
          3  recursive calls
        160  db block gets
       5795  consistent gets  <<---逻辑读大幅降低 0="" 1="" 151="" 508="" 534="" 576="" physical="" reads="" redo="" size="" bytes="" sent="" via="" sql*net="" to="" client="" received="" from="" roundtrips="" sorts="" (memory)="" (disk)="" rows="" processed="" <="" code=""></---逻辑读大幅降低></code></pre>

<p>这样改写以后，逻辑读大幅降低，执行时间降到95ms左右。并且这个优化方案不需要在两张表上创建任何的索引。</p>
<p>综上所述，优化的思路都是找出产生低效执行计划filter这个关键，然后判断到出现问题的根源是因为or存在导致无法走hash join只能走filter表连接方式的问题，复杂的or条件无法做or expansion。</p>
<p>知道了原因，就是根据相应的情况去进行优化，虽然创建索引可以达到这条SQL的最佳优化效果，但是运营商的环境，业务表往往需要不断的更新插入，所以经过考虑，最后向客户推荐了第二种优化方案。</p>
<p>所以，有时不是执行时间最快，消耗资源最少的优化方案就是最适合客户环境的，还需要权衡，有时可能是次优的方案才是最适合客户的，我们要学会取舍:-)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyoracle.com/2016/08/30/运营商异常缓慢的SQL优化/" data-id="ciz2evbez000qm0o5pwv2fd4w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oracle-sql-tuning/">oracle,sql tuning</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/09/28/mysql的CVE-2016-6662安全漏洞/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          mysql的CVE-2016-6662安全漏洞修复
        
      </div>
    </a>
  
  
    <a href="/2016/08/10/系统表空间异常增长二/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">SYSTEM表空间异常增长问题分析（二）</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Pelican/">Pelican</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/oracle/">oracle</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python-Pelican-GitHub-Markdown/">Python, Pelican, GitHub, Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle-troubleshooting/">oracle ,troubleshooting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle-11-2-0-4/">oracle,11.2.0.4</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle-sql-tuning/">oracle,sql tuning</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Mysql/" style="font-size: 10px;">Mysql</a> <a href="/tags/Python-Pelican-GitHub-Markdown/" style="font-size: 10px;">Python, Pelican, GitHub, Markdown</a> <a href="/tags/oracle-troubleshooting/" style="font-size: 10px;">oracle ,troubleshooting</a> <a href="/tags/oracle-11-2-0-4/" style="font-size: 20px;">oracle,11.2.0.4</a> <a href="/tags/oracle-sql-tuning/" style="font-size: 10px;">oracle,sql tuning</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/02/06/该奋斗了/">该奋斗了</a>
          </li>
        
          <li>
            <a href="/2017/01/03/2017_new_begining/">2017_new_begining</a>
          </li>
        
          <li>
            <a href="/2016/10/09/PMON_unable_to_acquire_latch的问题分析/">PMON unable to acquire latch的问题分析</a>
          </li>
        
          <li>
            <a href="/2016/09/30/JDBC参数导致大量的library cache lock/">JDBC参数导致大量的library cache lock</a>
          </li>
        
          <li>
            <a href="/2016/09/28/mysql的CVE-2016-6662安全漏洞/">mysql的CVE-2016-6662安全漏洞修复</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 TY<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>