<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>IT 职业生涯规划</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="IT职业生涯规划与技术分享">
<meta property="og:type" content="website">
<meta property="og:title" content="IT 职业生涯规划">
<meta property="og:url" content="http://tyoracle.com/index.html">
<meta property="og:site_name" content="IT 职业生涯规划">
<meta property="og:description" content="IT职业生涯规划与技术分享">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IT 职业生涯规划">
<meta name="twitter:description" content="IT职业生涯规划与技术分享">
  
    <link rel="alternate" href="/atom.xml" title="IT 职业生涯规划" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">IT 职业生涯规划</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">时间的朋友</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://tyoracle.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-该奋斗了" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/06/该奋斗了/" class="article-date">
  <time datetime="2017-02-05T16:00:00.000Z" itemprop="datePublished">2017-02-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/06/该奋斗了/">该奋斗了</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="假期都做了什么"><a href="#假期都做了什么" class="headerlink" title="假期都做了什么"></a>假期都做了什么</h2><p>2017年的春节就这样过去了，转眼就到了年初十了，在过去的将近十天时间里，你过得如何呢？是陪伴着家人？还是被一大帮朋友拉着在外面胡吃海喝？还是以特别的方式渡过这个鸡年的春节？当大部分人都处于完全放松的状态时，却有一小部分人，永不知倦，继续着自己学习的轨迹，远远地把我们抛在了身后。</p>
<p>这就是选择什么样渡过假期的方式，就决定了你未来的生活质量了。</p>
<p>相信今天应该是很多人假期结束后回到公司上班的第一天，刚结束假期，是不是有点假期综合症？这个生物钟早已习惯了半夜才睡，中午才起的模式了。早上当闹钟响起来的时候，艰难地爬起床来，那真的是痛苦。因为人不是机器，想切换模式就切换模式。那我们如何能快速的进入到新的角色呢？</p>
        
          <p class="article-more-link">
            <a href="/2017/02/06/该奋斗了/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyoracle.com/2017/02/06/该奋斗了/" data-id="ciz2evbd0000bm0o5e4kltovi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2017_new_begining" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/03/2017_new_begining/" class="article-date">
  <time datetime="2017-01-02T16:00:00.000Z" itemprop="datePublished">2017-01-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/03/2017_new_begining/">2017_new_begining</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>当时光飞逝，进入2017年已经三天了，感觉还是停留在2016里，恍如昨日。时间总是在过去了，才会让人感觉到飞快，拥有的时候，才不知如何使用，白白浪费在刷微信，浏览无聊的网页上。</p>
<p>在朋友圈，这几天不断的刷着2016的成绩与2017的计划，这种期望是好的，但是又有多少人在年底的时候能完成自己年初定下的计划，并且完成的呢？</p>
<p>在新一年的开始，的确需要对过去进行回顾，对未来进行规划，但是任何的一切，不会因为新的一年而改变，如未读的书依然在书柜里，未背的单词，还是不会，未跑的里程，还是需要用汗水去浇灌。如果你今年还是定下了要读多少本书，背多少单词，做多少事，只不过是把往年的计划重复。对你来说，2017并没有什么特别。</p>
<p>我们是需要将每一年活出精彩，还是重复过着每一年的生活呢？这需要我们每个人深入地思考。</p>
<p>在新年伊始，回顾与展望，的确让人有一种庄严的仪式感。这样可以让人有一种新生的感觉。那我也不能免俗，让自己在2017年写下新一年的初步计划。</p>
<p>2016年里发生了很多的事情，世界的，中国的，身边的，但那是外部的环境，你不能改变，那只能适应。2016年是一个知识变现的年，在这一年里，看到很多技术牛人，将知识通过网络变现，知识开始以各种不同的付费形式出现。而我也参与其中，成为付费学习的一份子。在2017，需要将这些付费学习的知识，整理成文字，内化在自己的思维里，才不枉付出时间与金钱进行学习。</p>
<p>财富自由，生涯规划，人生升级，这些概念，需要无时无刻的提醒自己去不断地思考，反省与努力。</p>
<p>2017年，需要更关注时间的消耗，时间是不可再生资源，你的时间花在了这些地方，就没有时间进行学习。时间放在那，成长就在那。希望是一个人前进的动力，虽然前路并不可知，但是认准了方向，只需去做就行了，做了，至少你往前移动了一点，能看清前方的路也多一点，所以怀着希望，认准方向，就拼命去努力，不要浪费时间在那里胡思乱想。</p>
<p>再多的计划都是空谈，实干出真知，简单地说，继续一百天的计划，一百天跑步，一百篇博客更新，一百天持续英语朗读，每天坚持碎片化学习付费订阅，学习冥想。</p>
<p>其实最好的执行方式，取于一张A4纸自制一个2017的日历，每坚持一天，就在上面打个圆圈，对，这是我准备去做的。</p>
<p>愿你我在2017年活出与2016年不一样的自我，而不是重复过去一年的自己。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyoracle.com/2017/01/03/2017_new_begining/" data-id="ciz2evbaq0000m0o5qbm9jroe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-PMON_unable_to_acquire_latch的问题分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/09/PMON_unable_to_acquire_latch的问题分析/" class="article-date">
  <time datetime="2016-10-08T16:00:00.000Z" itemprop="datePublished">2016-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/oracle/">oracle</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/09/PMON_unable_to_acquire_latch的问题分析/">PMON unable to acquire latch的问题分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>客户的环境是10.2.0.1+Linux单机版，没有打任何的PATCH，最近一段时间经常出现数据库hang住，无法使用sqlplus进行登录的操作，通过检查数据库日志发现，最近一次故障发生在9月4日的11：47分，客户不得不将整个数据库重启后，业务恢复正常</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>因为客户的ASH只保留了七天（这个是默认设置），所以无法通过数据库历史信息进行问题回溯，并且在后台日志目录里，只发现了orcl_pmon_4617.trc这个trace，包括alert_orcl.log里也没有任何的信息存在，基于如此少的信息，很难真正定位问题的根因。但我们通过丰富的经验，慢慢从pmon的trace里，整理出关键的线索，可能的原因指向了base Bug 4221927 : PMON HANGS UNABLE TO ACQUIRE LATCH FROM KSUKIA, INSTANCE WONT STARTUP</p>
<p>下面是整个的分析过程
        
          <p class="article-more-link">
            <a href="/2016/10/09/PMON_unable_to_acquire_latch的问题分析/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyoracle.com/2016/10/09/PMON_unable_to_acquire_latch的问题分析/" data-id="ciz2evbcs0007m0o5kmb5ccho" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oracle-troubleshooting/">oracle ,troubleshooting</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JDBC参数导致大量的library cache lock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/30/JDBC参数导致大量的library cache lock/" class="article-date">
  <time datetime="2016-09-29T16:00:00.000Z" itemprop="datePublished">2016-09-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/30/JDBC参数导致大量的library cache lock/">JDBC参数导致大量的library cache lock</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h2><p>本人TY，从事ORACLE DBA十五年，从ORACLE 8I开始，一直奋战在一线，本着对技术的狂热，一直走到今天，积累了大量的经验与案例，期待静下心来，将这些案例与经验化成文字，与大家分享，共同进步。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天要与大家分享的是一个关于JDBC参数设置引起数据库BUG的故事，也许大家会不以为然，BUG多么的简单，直接到metalink上去查不就可以了吗？但是解决问题的时候，你不知道是bug，我们只能从故障表现出来的种种蜘丝马迹去推断，把问题从未知向已知一步步推进。这才是故障解决的关键，我们要学习的是解决故障的思路，当你清晰了整个故障的前因后果，你会发现，寻寻觅觅，原来就是这么简单，但是正因为有了从未知到已知这个推断过程，才有了解决问题后那种乐趣，才体现了对困难的挑难，对能力的提升。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>故事的背景也如大多的故事一样，客户刚从11.1.0.7升级到11.2.0.3，升级后经常遇到’library cache lock’ 和’library cache: mutex X’ 等待事件，一个本来CPU平时占用不到10%的清闲系统，经常CPU占用百分百，严重影响了业务的正常运行。关于这个library cache，因为其结构复杂，并且在数据库结构中非常重要，所以出现问题的概率非常高，其实可以写一系列的文章，大家以后可以继续关注。</p>
<p>既然出现问题了，作为服务商，当然第一时间赶赴现场进行分析，因为出现library cache的问题，往往会占用大量的db time，从而影响到业务的正常运行，必须第一时间去解决问题，否则对客户的影响会越来越大。<br>
        
          <p class="article-more-link">
            <a href="/2016/09/30/JDBC参数导致大量的library cache lock/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyoracle.com/2016/09/30/JDBC参数导致大量的library cache lock/" data-id="ciz2evbb50001m0o5qlcgbw52" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql的CVE-2016-6662安全漏洞" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/28/mysql的CVE-2016-6662安全漏洞/" class="article-date">
  <time datetime="2016-09-27T16:00:00.000Z" itemprop="datePublished">2016-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/28/mysql的CVE-2016-6662安全漏洞/">mysql的CVE-2016-6662安全漏洞修复</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h2><p>本人TY，从事ORACLE DBA十五年，从ORACLE 8I开始，一直奋战在一线，本着对技术的狂热，一直走到今天，积累了大量的经验与案例，期待静下心来，将这些案例与经验化成文字，与大家分享，共同进步。</p>
<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>最近几天，在安全方面最热门的话题应该是一个独立的研究组织发现多处严重的Mysql漏洞，此次通报的是其中比较严重的一个漏洞CVE-2016-6662，它允许攻击者远程注入恶意设置到被攻击服务器的Mysql配置文件(my.cnf)中，导致更加严重的后果。</p>
<p>该漏洞影响所有默认配置的Mysql版本分支(5.7、5.6、5.5)，包括最新的版本，并可能被攻击者进行本地或者远程的利用。exp既可以通过网络连接或者利用类似phpmyadmin之类的web管理工具，以及SQL注入漏洞等。</p>
<p>SQL注入漏洞是在web应用中最常见的漏洞之一，在存在注入漏洞的情况下，攻击者可以配合CVE-2016-6662进行更加深入的入侵。如果被攻击服务器有运行受影响的mysql版本，攻击用该漏洞的EXP可以以root权限执行任意代码，从而完全控制被攻击服务器。</p>
<p>该漏洞需要认证访问MYSQL数据库（通过网络连接或者像phpMyAdmin的web接口），以及通过SQL注入利用。攻击者成功利用该漏洞可以以ROOT权限执行代码，完全控制服务器。</p>
<p>利用条件：首先你要有一个Mysql低权限用户，仅需有FIle权限（例如：虚拟主机通常会提供，因为需要导入导出文件），即可实现Root权限提升，进而控制服务器</p>
        
          <p class="article-more-link">
            <a href="/2016/09/28/mysql的CVE-2016-6662安全漏洞/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyoracle.com/2016/09/28/mysql的CVE-2016-6662安全漏洞/" data-id="ciz2evbbn0002m0o5lv5rvq68" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mysql/">Mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-运营商异常缓慢的SQL优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/30/运营商异常缓慢的SQL优化/" class="article-date">
  <time datetime="2016-08-29T16:00:00.000Z" itemprop="datePublished">2016-08-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/oracle/">oracle</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/30/运营商异常缓慢的SQL优化/">运营商异常缓慢SQL优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="运营商异常缓慢SQL优化"><a href="#运营商异常缓慢SQL优化" class="headerlink" title="运营商异常缓慢SQL优化"></a>运营商异常缓慢SQL优化</h1><p>今天到一个运营商进行深度巡检时，发现一条SQL运行次数频繁，并且占用资源非常高，这条SQL是对两个千万级的大表进行关联，根据电话号码进行查询，原来的语句运行非常缓慢，常常半个小时都执行不完，真不知道业务是怎么忍受运行这么缓慢的SQL。</p>
<p>因为需要对客户信息进行保密，只能在自己电脑上模拟相应的数据与优化结果</p>
<p>先创建两个表，然后模拟表的数据，分别插入3千万与2千5百万<br>
        
          <p class="article-more-link">
            <a href="/2016/08/30/运营商异常缓慢的SQL优化/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyoracle.com/2016/08/30/运营商异常缓慢的SQL优化/" data-id="ciz2evbez000qm0o5pwv2fd4w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oracle-sql-tuning/">oracle,sql tuning</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-系统表空间异常增长二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/10/系统表空间异常增长二/" class="article-date">
  <time datetime="2016-08-09T16:00:00.000Z" itemprop="datePublished">2016-08-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/oracle/">oracle</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/10/系统表空间异常增长二/">SYSTEM表空间异常增长问题分析（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="继续分析"><a href="#继续分析" class="headerlink" title="继续分析"></a>继续分析</h1><p>又一个周未过去了，但是在周未的时候，系统再次报错，在system表空间已扩展到32G的情况下，逼不得已再把system表空间再扩充了64G。这样下去不是办法啊，必须要想出一个彻底解决的方案。</p>
<p>检查hisgram$这个表，发现已增长了一千多万</p>
<pre><code> 
SQL> select count(*) from histgrm$;            

  COUNT(*)            
----------            
17679019

</code></pre>

<p>检查这个表占用最多的是那些表的柱状图统计信息</p>
<pre><code> 

Table    count(*)        partitions 
F_XXXXX_DDDDDDDDDD_H    187883        1500  <<<------ 33="" 62="" 1907="" 10176="" 12073="" 12821="" 12877="" 12878="" 13190="" 14825="" 16040="" 16555="" 17268="" 17673="" 17804="" 23433="" 65124="" 77148="" f_xx_ddddd_ggggg_vvvv_h="" <<<------="" a_d_xxx_xxxx_ddu="" f_ag_loan_cont_s="" f_ag_loan_apl_msg_s="" f_ag_elec_acpt_dra_s="" f_as_guar_msg_s="" f_pt_cred_org_pt_msg_s="" f_ev_in_lend_buss_s="" f_ev_exp_bar_trad_s="" f_ev_loan_out_acc_msg_s="" f_ev_remit_fund_trad_s="" f_ev_imp_arr_ord_trad_s="" f_ev_abch_rem_fud_trad_s="" f_ev_cbill_coll_trad_s="" f_ev_online_aut_orig_s="" <="" code=""></------></code></pre>        

<p>前面三个表的记录数最多，特别是前面两个，每个表的分区数一千多个，所以每收集一次统计信息，就会增加非常多的记录，所以system 表空间消耗得特别快。</p>
<p>既然知道是因为柱状图的收集而引起的，那柱状图的作用是什么呢？当系统中的某些表存在高度不均匀的数据分布时，使用柱状图能够产生更好的选择性评估，从而产生更加优化的执行计划，如判定是选择走索引好还是走全表好。其实这对于普通的ORACLE数据库是非常好的特性，因为使用索引，能提高普通ORACLE数据库的性能，但我们现在的环境则相反，我们现在是EXADATA，在EXADATA里，通常建议是尽量减少索引，利用EXADATA的storage index特性能提高SQL的性能，使用普通的btree索引，反而性能会下降得厉害。正因为此，这些业务表上，除了主键外，都没有索引，因此，柱状图对于exadata的环境是没有什么用处的。</p>
<p>既然知道了原理，那我们就明白，histgrm$的异常增长，柱状图的收集，不会给我们的系统带来任何的好处，那我们为什么还要收集它呢？</p>
<p>检查系统当前的统计信息收集策略</p>
<pre><code> 
SQL> select client_name,status from dba_autotask_client;                 

CLIENT_NAME                                                      STATUS  
/-------------------------------------------------------------- /--------
auto optimizer stats collection                                  ENABLED 
auto space advisor                                               ENABLED 
sql tuning advisor                                               ENABLED 
</code></pre>    

<p>当前是系统默认的自动收集，即表的数据量变化达到了表的大小10%时，即会自动收集统计信息。而这个自动收集统计信息的功能，其同时也会自动收集柱状图的相关信息，正因为这样，才会导致每个周未，system表空间都异常增长，原因就是周未的时候，作了自动的统计信息收集。</p>
<pre><code> 
select dbms_stats.get_prefs('method_opt') from dual;
DBMS_STATS.GET_PREFS('METHOD_OPT')
/-------------------------------------------------------------------------------
FOR ALL COLUMNS SIZE AUTO

</code></pre>    

<p>从上面的查询中就可以看到当前自动收集是打开了柱状图的自动收集功能的。我们也可以单独查询上述最大的那三张表是不是也是打开了柱状图的自动收集功能的。</p>
<pre><code> 
SQL> select dbms_stats.get_prefs('method_opt','DWUSR','F_XXXXX_DDDDDDDDDD_H') from dual;

DBMS_STATS.GET_PREFS('METHOD_OPT','DWUSR','F_XXXXX_DDDDDDDDDD_H')
/--------------------------------------------------------------------------------
FOR ALL COLUMNS SIZE AUTO


SQL> select dbms_stats.get_prefs('method_opt','DWUSR','F_XX_DDDDD_GGGGG_VVVV_H') from dual;

DBMS_STATS.GET_PREFS('METHOD_OPT','DWUSR','F_XX_DDDDD_GGGGG_VVVV_H')
/--------------------------------------------------------------------------------
FOR ALL COLUMNS SIZE AUTO



SQL> select dbms_stats.get_prefs('method_opt','DWUSR','A_D_XXX_XXXX_DDU') from dual;

DBMS_STATS.GET_PREFS('METHOD_OPT','DWUSR','A_D_XXX_XXXX_DDU')
/--------------------------------------------------------------------------------
FOR ALL COLUMNS SIZE AUTO

</code></pre>    

<p>从上述的结果更加确信了上述的推测，现在我们要验证的是，不收集这个柱状图统计信息，这个histgrm$基表是不是就不会停止增长了。我们取三个表中最小的那个表A_D_XXX_XXXX_DDU进行试验。</p>
<pre><code> 
SQL>   exec dbms_stats.DELETE_TABLE_STATS(OWNNAME=> 'DWUSR',TABNAME=>'A_D_XXX_XXXX_DDU');   

PL/SQL procedure successfully completed.

我们先删除了这个表的统计信息

SQL> select count(*) from histgrm$ a where a.obj# in (select b.object_id from dba_objects b where b.object_name='A_D_XXX_XXXX_DDU');

  COUNT(*)
/----------
         0
删除后，在histgrm$里就没有这个表的相关信息了，histgrm$的空间就可以被重用了。但因为是数据字典表，这个空出来的空间不能被回收，只能被另外的记录重用。

</code></pre>


<p>我们重新以不收集柱状图的方式重新收集这个表的信息，指定</p>
<p>METHOD_OPT=&gt;’for all columns size 1’</p>
<pre><code> 
15:20:53 SQL> exec dbms_stats.GATHER_TABLE_STATS(OWNNAME=> 'DWUSR',TABNAME=>'A_D_XXX_XXXX_DDU',ESTIMATE_PERCENT=>dbms_stats.auto_sample_size,METHOD_OPT=>'for all columns size 1') ;

PL/SQL procedure successfully completed.

Elapsed: 00:34:35.72

15:55:31 SQL>                   select count(*) from histgrm$ a where a.obj# in (select b.object_id from dba_objects b where b.object_name='A_D_XXX_XXXX_DDU');

  COUNT(*)
----------
         0

Elapsed: 00:00:00.03    

</code></pre>

<p>收集完成后，我们检查histgrm$，果然如我们所期望的一样，没有任何的记录，即在不收集柱状图的情况下，这个histgrm$基表是不会增长的。</p>
<p>OK，那我们验证成功了，既然这个柱状图对exadata 环境没什么用，那我们就把全库的柱状图都禁止好了，进行以下的设置</p>
<pre><code> 
16:14:22 SQL>      exec dbms_stats.set_param(pname=>'METHOD_OPT',pval=>'FOR ALL COLUMNS SIZE 1');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
16:19:57 SQL> select dbms_stats.get_prefs('method_opt') from dual;

DBMS_STATS.GET_PREFS('METHOD_OPT')
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
FOR ALL COLUMNS SIZE 1

全库的统计信息收集属性改变了，不收集柱状图的信息

Elapsed: 00:00:00.00
16:20:11 SQL> select dbms_stats.get_prefs('method_opt','DWUSR','F_XXXXX_DDDDDDDDDD_H') from dual;

DBMS_STATS.GET_PREFS('METHOD_OPT','DWUSR','F_XXXXX_DDDDDDDDDD_H')
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
FOR ALL COLUMNS SIZE 1

Elapsed: 00:00:00.00
16:20:25 SQL> 
对应的表的收集属性也跟着变化了
</code></pre>

<p>至此问题得到完美的解决，SYSTEM表空间再不会因为histgrm$这个表的异常增长而撑爆。但是，如果在非EXADATA的环境，并且表字段的数据分布不均的情况下，柱状图还是非常有用的，这样 histgrm$增长就在所难免了。解决问题，只要知道了其原理，具体问题具体分析，一般都能找到解决方案。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyoracle.com/2016/08/10/系统表空间异常增长二/" data-id="ciz2evbcu0008m0o5p2slg2fa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oracle-11-2-0-4/">oracle,11.2.0.4</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-系统参数设置不当导致ORACLE坏块的故事" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/02/系统参数设置不当导致ORACLE坏块的故事/" class="article-date">
  <time datetime="2016-08-01T16:00:00.000Z" itemprop="datePublished">2016-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Pelican/">Pelican</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/02/系统参数设置不当导致ORACLE坏块的故事/">系统参数设置不当导致ORACLE坏块的故事</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h2><p>本人TY，从事ORACLE DBA十五年，从ORACLE 8I开始，一直奋战在一线，本着对技术的狂热，一直走到今天，积累了大量的经验与案例，期待静下心来，将这些案例与经验化成文字，与大家分享，共同进步。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为从事DBA多年的TY来说，与奋战在一线的同行们一样，每天都会遇到各种各样的奇怪问题，这些问题有些莫名奇妙的自动出现，然后莫名奇妙的自动消失，但这世上不会有无缘无故的爱，也不会有无缘无故的恨：-），TY是一个喜欢创根问根的人，非常喜欢接受数据库奇怪问题的挑战。也可以简称“自虐”。</p>
<p>最近两天，有个客户打电话给TY，说他的数据库刚从AIX迁移到PC 服务器上，使用的是OLE 6的操作系统，最近备份时，出现报错，系统中居然报归档文件存在坏块。</p>
<p>这个就非常奇怪了，数据库出现坏块就常见，归档文件出现坏块这个极为罕见，这挑起了TY的好奇心，决定到客户现场一探究竟。</p>
<p><code>这里讲述的是一个，对于未知问题，无从下手的情况下，如何分析解决问题的过程。</code></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p><strong>客户的数据库是11.2.0.1，刚从AIX上迁移到PC服务器上，迁移时，归档文件是放到FRADG上的，备份一直没有问题，但最近将归档目录修改到文件系统后，备份时alter.log就出现如下的报错：</strong></p>
   <pre><code>RMAN>backup archivelog all;

  Starting backup at 06-Jan-16
  current log archived
  allocated channel: ORA_DISK_1
  channel ORA_DISK_1: SID=148 device type=DISK
  channel ORA_DISK_1: starting archived log backup set
  channel ORA_DISK_1: specifying archived log(s) in backup set
  input archived log thread=1 sequence=4 RECID=1 STAMP=793260539
  input archived log thread=1 sequence=5 RECID=2 STAMP=793260573
  input archived log thread=1 sequence=6 RECID=3 STAMP=793260647
  input archived log thread=1 sequence=7 RECID=4 STAMP=793260764
  input archived log thread=1 sequence=8 RECID=5 STAMP=793260835
  input archived log thread=1 sequence=9 RECID=6 STAMP=793260868A6
  channel ORA_DISK_1: starting piece 1 at 06-Jan-16
  RMAN-571: ===========================================================
  RMAN-569: =============== ERROR MESSAGE STACK FOLLOWS ===============
  RMAN-571: ===========================================================
  RMAN-3009: failure of backup command on ORA_DISK_1 channel at 01/06/2016
  06:21:59
  ORA-19599: block number 2048 is corrupt in archived log
  /u01/app/oracle/flash_recovery_area/ORCL/archivelog/2016_01_06/o1_mf_1_10_84j
  xxb4d_.arc</code></pre>





  <pre><code>[oracle@localhost trace]$ tail -f alert_orcl.log

Bad header found during backing up archived log
  Data in bad block - seq:0. bno:0. time:0
  beg:0 cks:0
  calculated check value: 0
  Reread of seq=10, blocknum=2048,
  file=/u01/app/oracle/flash_recovery_area/ORCL/archivelog/2016_01_06/o1_mf_1_1
  0_84jxxb4d_.arc, found same corrupt data
  Reread of seq=10, blocknum=2048,
  file=/u01/app/oracle/flash_recovery_area/ORCL/archivelog/2016_01_06/o1_mf_1_1
  0_84jxxb4d_.arc, found same corrupt data
  Reread of seq=10, blocknum=2048,
  file=/u01/app/oracle/flash_recovery_area/ORCL/archivelog/2016_01_06/o1_mf_1_1
  0_84jxxb4d_.arc, found same corrupt data
  Reread of seq=10, blocknum=2048,
  file=/u01/app/oracle/flash_recovery_area/ORCL/archivelog/2016_01_06/o1_mf_1_1
  0_84jxxb4d_.arc, found same corrupt data
  Reread of seq=10, blocknum=2048,
  file=/u01/app/oracle/flash_recovery_area/ORCL/archivelog/2016_01_06/o1_mf_1_1
  0_84jxxb4d_.arc, found same corrupt data
  Deleted Oracle managed file
  /u01/app/oracle/flash_recovery_area/ORCL/backupset/2016_01_06/o1-mf_annnn_TAG20160106T062152_84jyb44j_.bkp</code></pre>


<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于corrupt data，一般都是发生在数据库文件中，有两种情况，一种是物理损坏，是指数据库不能读取到该块内部的数据结构，一般是因为硬件出现问题，内存问题、OS问题、IO子系统问题等引起。而逻辑损坏，则大多是指数据库能读取到该块的数据结构，但是因为数据结构的值不一致，从而被数据库标识为坏块，大部分的逻辑损坏，很多都是因为ORACLE 的BUG 造成的。</p>
<p>但对于客户现在这种情况，是归档文件损坏。而用户的环境是新的机器，存储也是新的。硬件出现问题的概率较低，对于内存，OS，IO等问题，如果存在，肯定数据库本身的数据文件也会报坏块，而现在只是归档文件有问题，所以基本上可以排除物理坏块的的可能。</p>
<p>对于归档文件出现坏块这种情况，在TY十多年的DBA生涯中也极少遇到，正在苦思冥想，不知如何下手的时候，突然灵光一闪，客户曾提到过，当刚迁移完的时候，归档是存放在ASM中的，那个时候没有出现这种情况。只有迁移到文件系统后，才出现这种情况，这是一条多么重要的线索啊。</p>
<p>认真思考了一下归档文件涉及到的进程，无非就是arch写，然后备份时RMAN读的时候报错。那是不是写的时候出现了问题呢？</p>
<p>为了证实自己的想法，决定对归档进程进行trace，看看归档进程在进行归档时，ASM与文件系统之间有没有什么特别的地方。</p>
<pre><code>
会话一：
# ps -ef|grep arc
oracle    2768     1  0 22:11 ?        00:00:01 ora_arc0_orcl
root      3000  2395  0 23:09 pts/1    00:00:00 grep arc

strace –o /tmp/strace.log –p 2768

会话二：
sqlplus / as sysdba
alter syste switch logfile;
</code></pre>

<p>这个时候，会产生归档进程的整个归档trace，仔细检查这个trace，发现写文件时，只有以下的相关信息：</p>
<pre><code>
open("...../1_21_900928246.dbf", O_RDWR|O_SYNC|O_DIRECT) = 21
open("...../1_21_900928246.dbf", O_RDWR|O_SYNC|O_DIRECT) = 21
open("...../1_21_900928246.dbf", O_RDWR|O_SYNC|O_DIRECT) = 21
open("...../1_21_900928246.dbf", O_RDWR|O_SYNC|O_DIRECT) = 21
</code></pre>

<p>然后，将归档路径重新设置回ASM里面，重做上述的过程，对比一下strace的输出</p>
<pre><code>
open("/dev/raw/raw7", O_RDWR|O_NONBLOCK|O_SYNC|O_DIRECT) = 20
open("/dev/raw/raw6", O_RDWR|O_NONBLOCK|O_SYNC|O_DIRECT) = 20
open("/proc/6236/stat", O_RDONLY)       = 20
</code></pre>

<p>发现其多了一个O_NONBLOCK的关键字，对于一个IO操作的句柄会遇到阻塞IO 和非阻塞IO 的概念, 这里对于这两种socket 先做一下说明：<br>基本概念：<br>  阻塞IO::<br>   socket 的阻塞模式意味着必须要做完IO 操作（包括错误）才会返回。非阻塞IO::<br>   非阻塞模式下无论操作是否完成都会立刻返回，需要通过其他方式来判断具体操作是否成功。</p>
<p>存在O_NONBLOCK的关键字，即其是非阻塞的IO操作，这从ASM的原理上可以推测到，因为ASM是直接操作底层磁盘的，其没有文件缓存，那问题会不会出在O_SYNC|O_DIRECT这两个参数上，难道是写归档日志的方式不对，导致了归档出现坏块？</p>
<p>马上到metelink上输入O_SYNC O_DIRECT进行搜索，发现排在BUG的第一位就有一个相类似的BUG，其描述是在linux上使用EXT4的文件系统存放archived log ,redo log ,datafile 文件时，数据库的参数filesystemio_options=setall时，就会出现数据库坏块。</p>
<p><img src="file:///C:\Users\Tony\Pictures\1.jpg" alt="image"></p>
<p>柳暗花明又一村，看到这个BUG，心中一阵狂喜，客户是不是命中这个BUG呢？是不是离解决问题不远了。马上登录到系统中一看归档目录，发现果然是以ext4来加载的。</p>
<p>再到数据库里查看</p>
<pre><code>
SQL> show parameter filesystem

NAME                    TYPE        VALUE
----------------------  ----------- --------
filesystemio_options    string      SETALL
</code></pre>

<p>果然与这个BUG相匹配，那么这个filesystemio_options是什么参数呢？ORACLE数据库里面有两个参数控制IO的行为，也就是说，我们可以通过filesystemio_options与disk_asynch_io这两个参数来优化ORACLE数据库的IO性能。</p>
<p>filesystemio_options 这个参数是允许数据库对IO进行间接或直接，同步或异步读写，这个参数默认是none，这意味着，数据库对文件系统IO操作模式是同步读写，对文件系统的cache是间接读写。Oracle推荐这个参数是使用setall，这个参数值是执行IO操作时绕过了文件系统的cache，直接读写到磁盘上。</p>
<p>而disk_asynch_io这个参数是默认为true的，即启用异步IO。</p>
<p>基于上述的原理，所以当filesystemio_options设置为setall时，我们看到O_SYNC|O_DIRECT的关键字，其绕过了EXT4上的文件系统缓存，直接对IO进行操作，导致触发了14594193这个BUG。</p>
<h2 id="原因总结及建议"><a href="#原因总结及建议" class="headerlink" title="原因总结及建议"></a>原因总结及建议</h2><p>通过对上述的分析，可以知道是因为客户将归档文件存放到了EXT4上的文件系统，而数据库的参数filesystemio_options设置为setall时，数据库在做IO操作时，绕过了EXT4文件系统的缓存，从而触发了BUG而引起了坏块，所以这种坏块属于逻辑坏块。</p>
<p>这个问题在metalink的文档ORA-1578 ORA-353 ORA-19599 Corrupt blocks with zeros when filesystemio_options=SETALL on ext4 file system using Linux (文档 ID 1487957.1)里有详细的描述，在这里我就不帖出来了，各位自已去查阅吧。</p>
<p>这个文档提及，从10.1.0.2 to 12.1.0.1都存在这个BUG，也就是说，从10.2.0.2引入filesystemio_options这个参数，只要设为SETALL，结合EXT4，就会有可能遇到这个BUG。</p>
<h2 id="建议："><a href="#建议：" class="headerlink" title="建议："></a><strong>建议：</strong></h2><p>万事知道原理后，解决就非常容易了，要不修改filesystemio_options这个参数为非SETALL值。</p>
<pre><code>
Workaround:
The workaround to avoid corruptions in the Oracle database files is to set filesystemio_options=NONE or filesystemio_options=DIRECTIO or filesystemio_options=ASYNCH in the database parameter file (spfile / init<sid>.ora).
</sid></code></pre>

<p>要不就不要使用EXT4来存放数据库的相关文件，改为其他文件系统格式或直接存放到ASM上。</p>
<p>终于解决问题，可以回家了：-）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyoracle.com/2016/08/02/系统参数设置不当导致ORACLE坏块的故事/" data-id="ciz2evbbw0003m0o51l0n4xh6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python-Pelican-GitHub-Markdown/">Python, Pelican, GitHub, Markdown</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-系统表空间异常增长一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/02/系统表空间异常增长一/" class="article-date">
  <time datetime="2016-08-01T16:00:00.000Z" itemprop="datePublished">2016-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/oracle/">oracle</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/02/系统表空间异常增长一/">SYSTEM表空间异常增长问题分析（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h2><p>本人TY，从事ORACLE DBA十五年，从ORACLE 8I开始，一直奋战在一线，本着对技术的狂热，一直走到今天，积累了大量的经验与案例，期待静下心来，将这些案例与经验化成文字，与大家分享，共同进步。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在7月30日，某客户的exadata出现aud$无法扩充system表空间的错误，检查发现，当前system表空间只有4G大小，经现场维护人员将system表空间resize到20G后，问题暂时得到解决。</p>
<p>但是在8月3日现场支持检查发现，当前的SYSTEM表空间已经增长到16G，对于三四天增长这么快，需要找出原因。</p>
<h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>在7月30日时，一直以为是aud$占的空间较大，导致了空间爆满，但现场检查时，却发现与我们想像的不致。</p>
<p>检查当前system表空间占用最多的对象</p>
<pre><code> SQL> select * from (select owner,segment_name,bytes/1024/1024 "size M" from dba_segments where tablespace_name='SYSTEM' order by 3 desc) where rownum <10; 50="" 52="" 53="" 54="" 240="" 312="" 672="" 14301="" owner="" segment_name="" size="" m="" ------------------------------="" ---------------------------------------------------------------------------------="" ----------="" sys="" c_obj#_intcol#="" hist_head$="" i_h_obj#_col#="" i_hh_obj#_col#="" i_hh_obj#_intcol#="" tabpart$="" sys_lob0000001100c00003$$="" c_file#_block#="" i_obj5="">
</10;></code></pre>


<p>发现占用最大的对象是C_OBJ#_INTCOL#，这个对象已经占了近14G，而aud$却排不上前十，看来经验误人，这个C_OBJ#_INTCOL#是什么对象呢？这个是一个 cluster对象。</p>
<p>簇表(cluster) 是一种可以选的存储数据方式。簇表由1组拥有相同的列而且经常被一起使用的数据表构成，这组表在存储时会共享一部分Data Blocks, 例如，employees 和 departments表都包含department_id 这个列。 当用户将这两个表组合成1个簇表时，Oracle在物理上将employees 和 departments 两张表各行的department_id 字段存储在1个Data block里。</p>
<p>cluster table在ORACLE的系统表上使用得较多，我们查一下这个cluster涉及的是那一个对象，可以通过dba_tables查到</p>
<pre><code>  
SQL> select owner,table_name,cluster_name from dba_tables where table_name='HISTGRM$';

OWNER                          TABLE_NAME                     CLUSTER_NAME
------------------------------ ------------------------------ ------------------------------
SYS                            HISTGRM$                       C_OBJ#_INTCOL#


SQL>  select owner,table_name,BLOCKS*32/1024,tablespace_name  from dba_tables where table_name='HISTGRM$';

OWNER                          TABLE_NAME                     BLOCKS*32/1024 TABLESPACE_NAME
------------------------------ ------------------------------ -------------- ------------------------------
SYS                            HISTGRM$                             13817.75 SYSTEM
</code></pre>


<p>可以看到这个cluster是HISTGRM$所用，并且这个cluster的大小就是这个HISTGRM$表的大小。为什么是这个表占据了system最多的空间呢？我们进一步研究，</p>
<p>histgrm$这个表存储的是column statistics (histograms)，即列的柱状图信息，并且从11.2.0.4开始，这个列的统计表有了一些细微的变化，增加了default value这个列，即以前不会收集柱状图的列，增加了这个列后，也会强制收集这个列的信息。</p>
<p>根据Mos的Cluster C_OBJ#_INTCOL# Growing Too Fast (Doc ID 403824.1)描述，这个基表的记录，会随着你的子分区数量的增长而呈几何级的增长。如你有55000个子分区，每个子分区有100列，每个列有200个柱状图的bucket，那么histgrm$在每次统计信息收集时， 就会增长<br>55000<em>100</em>200 = approx 1 billion rows</p>
<p>这是一个非常大的数据，当然，你的子分区不会有100列那么多，也可能不会有55000个分区，但上述的公式展示了，随着子分区的增长，每收集一次统计信息，HISTGRM$基表的的数据量会急剧增加。</p>
<p>我们检查一下当前系统中存有的子分区数量</p>
<pre><code> 
SQL> select count(*) from histgrm$;

  COUNT(*)
----------
   8417868

当前这个基表已经有8百多万行了
SQL>  select count(*) from dba_tab_subpartitions;

  COUNT(*)
----------
    113565

</code></pre>


<p>那就奇怪了，为什么一个周未过去，这个基表就急剧增长呢？以前没有这样的事呢？经查，原来系统的自动统计信息收集并没有开启，即系统不会在每天凌晨进行统计信息收集，所以system表空间一直在4G以内而没有任何的问题。</p>
<p>但为什么周未会出现system表空间不足呢？那是因为开发人员在进行完表迁移后，为了确保跑批能顺利完成，所以手工执行了统计信息的收集，所以导致了HISTGRM$基表数据的急剧增长，从而快速占据了system表空间，而aud$也是一个只要有新的连接或操作时，就会插入新的数据的，当system空间被HISTGRM$基表占据时，aud$也没有空间插入数据，所以报错。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>从上述的分析可以看到，当前系统存在两个问题，统计信息的收集没有开启，所以系统中表的统计信息不准确，将会导致执行计划不准，对跑批有较大影响。但是一旦开启统计信息的自动收集，那么，系统中存在着11万个子分区，将会导致HISTGRM$急剧增长。而且这个表增长后，无法通过删除数据进行收缩。</p>
<p>通过综合考虑，建议对关键的业务表进行手工的统计信息收集，并且扩充system表空间到较大的空间，并且加强对此表空间的监控，避免空间不足。这样可以保证主要的业务表涉及的SQL执行计划是准确的，另外，减少了自动收集统计信息自动收集的分区数量，使HISTGRM$能可控增长。</p>
<blockquote>
<p>Cluster C_OBJ#_INTCOL# Growing Too Fast (Doc ID 403824.1)    To BottomTo Bottom    </p>
<p>In this Document<br>Symptoms<br>Cause<br>Solution<br>APPLIES TO:</p>
<p>Oracle Database - Enterprise Edition - Version 10.2.0.2 to 11.2.0.4 [Release 10.2 to 11.2]<br>Information in this document applies to any platform.<br><strong><em> Checked for relevance on 6-Oct-2014 </em></strong><br><strong><em> Checked for relevance on 8-Mar-2016 </em></strong></p>
<p>SYMPTOMS</p>
<p>Cluster C_OBJ#_INTCOL# is growing too fast.<br>CAUSE</p>
<p>The default stats job (GATHER_STATS_JOB) or any other job based on the DBMS_STATS used to collect Database statistics is being run frequently, while having a large number of subpartitions within the database.<br>To explain how the large number of subpartitions plays a role in the problem, consider the following example:</p>
<p>If 55000 subpartitions are being used, all of which have data and if each subpartition has 100 columns and further if the histogram has 200 buckets, then the worst case scenario for number of rows in the histgrm$ table for these objects is:</p>
<p>55000<em>100</em>200 = approx 1 billion rows</p>
<p>That’s the worst case scenario since there may not be 100 columns and all subpartitions may not have data and all columns may not have 200 buckets. But it illustrates the point that histograms can take up a lot of space as new objects are created and new data is loaded.</p>
<p>To make sure of the previous information, perform the following SQL queries:</p>
<ol>
<li><p>SQL&gt; SELECT STATE FROM DBA_SCHEDULER_JOBS WHERE JOB_NAME = ‘GATHER_STATS_JOB’;</p>
<p>If the result is “scheduled”, then the default stats job is automatically running.</p>
</li>
<li><p>SQL&gt; select job_name, schedule_name, last_start_date,repeat_interval,next_run_date from dba_scheduler_jobs;</p>
<p>SQL&gt; select * from dba_scheduler_wingroup_members;</p>
<p>SQL&gt; select * from dba_scheduler_window_details;</p>
<p>This is to check for any other job that gathers statistics and determine its scheduled run time and that of the default stats job.</p>
</li>
<li><p>SQL&gt; select count(*) from histgrm$;</p>
<p>Before and after running the job, if the histgrm$ number of rows increases obviously, then the assumptions are correct.</p>
</li>
<li><p>Check the number of subpartitions in the database if it has been increased or not.</p>
</li>
</ol>
<p>SOLUTION</p>
<p>To workaround this issue:</p>
<ol>
<li><p>Adjust the scheduler of the jobs so as not to run so often or run them manually.</p>
</li>
<li><p>Avoid adding so many subpartitions to the database.</p>
</li>
</ol>
<p>Other than recreating the database, there is no other supported way to reduce the size of the cluster.</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tyoracle.com/2016/08/02/系统表空间异常增长一/" data-id="ciz2evbck0005m0o56xbduwc1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oracle-11-2-0-4/">oracle,11.2.0.4</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Pelican/">Pelican</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/oracle/">oracle</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python-Pelican-GitHub-Markdown/">Python, Pelican, GitHub, Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle-troubleshooting/">oracle ,troubleshooting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle-11-2-0-4/">oracle,11.2.0.4</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle-sql-tuning/">oracle,sql tuning</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Mysql/" style="font-size: 10px;">Mysql</a> <a href="/tags/Python-Pelican-GitHub-Markdown/" style="font-size: 10px;">Python, Pelican, GitHub, Markdown</a> <a href="/tags/oracle-troubleshooting/" style="font-size: 10px;">oracle ,troubleshooting</a> <a href="/tags/oracle-11-2-0-4/" style="font-size: 20px;">oracle,11.2.0.4</a> <a href="/tags/oracle-sql-tuning/" style="font-size: 10px;">oracle,sql tuning</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/02/06/该奋斗了/">该奋斗了</a>
          </li>
        
          <li>
            <a href="/2017/01/03/2017_new_begining/">2017_new_begining</a>
          </li>
        
          <li>
            <a href="/2016/10/09/PMON_unable_to_acquire_latch的问题分析/">PMON unable to acquire latch的问题分析</a>
          </li>
        
          <li>
            <a href="/2016/09/30/JDBC参数导致大量的library cache lock/">JDBC参数导致大量的library cache lock</a>
          </li>
        
          <li>
            <a href="/2016/09/28/mysql的CVE-2016-6662安全漏洞/">mysql的CVE-2016-6662安全漏洞修复</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 TY<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>